#include <i915_drm.h>

/*******************
  There are three ioctl calls that can write to a GEM:
     1. i915_gem_mmap_offset_ioctl
     2. i915_gem_mmap_ioctl
     3. i915_gem_pwrite_ioctl
*******************/

/*******************
 MMAP OFFSET METHOD
*******************/

/* The application first calls this to get an offset to pass to mmap.
   We're going to use this as an identifier, so store it */
kprobe:i915_gem_mmap_offset_ioctl /comm == "bude"/
{
  @__offset_arg[tid] = (uint64) arg1;
}
/* We can also go ahead and pick up the struct drm_i915_gem_object. */
kprobe:i915_gem_object_has_struct_page /(comm == "bude") && (@__offset_arg[tid])/
{
  $obj = arg0;
  @__offset_obj[tid] = $obj;
}
kretprobe:i915_gem_mmap_offset_ioctl /(comm == "bude") && @__offset_arg[tid] && @__offset_obj[tid]/
{
  $mmap_args = (struct drm_i915_gem_mmap_offset *) @__offset_arg[tid];
  @mmap_offset_arg[$mmap_args->offset] = $mmap_args;
  @mmap_offset_obj[$mmap_args->offset] = @__offset_obj[tid];
  printf("We found an offset %llu in thread %lu\n", $mmap_args->offset, tid);
  
  /* Shut the door behind us */
  delete(@__offset_arg[tid]);
  delete(@__offset_obj[tid]);
}

/* Now that we have an offset identifier, find the mmap call that corresponds to that offset */
kprobe:do_mmap /comm == "bude"/
{
  $pgoff = arg5 * 4096;
  if($pgoff == 0) {
    return;
  }
  if(@mmap_offset_arg[$pgoff] == 0) {
    printf("WARNING: mmap offset was zero in thread %lu, pgoff = %lu!\n", tid, $pgoff);
    return;
  }
  if(@mmap_offset_obj[$pgoff] == 0) {
    printf("WARNING: mmap obj was zero in thread %lu, pgoff = %lu!\n", tid, $pgoff);
    return;
  }
  $obj = @mmap_offset_obj[$pgoff];
  printf("SUCCESS: I found the mmap call for offset %llu, obj %p!\n", $pgoff, $obj);
  @mmap_pgoff[tid] = $pgoff;
  @mmap_obj[tid] = $obj;
}

/* If we made it this far, we've got the mmap call that relates to a GEM that's about to be written to.
   Let's store the pointer that mmap returns, so that we can read it later. */
kretprobe:do_mmap /(comm == "bude") && (@mmap_pgoff[tid]) && (@mmap_obj[tid])/
{
  $obj = @mmap_obj[tid];
  @mmap_addr[$obj] = (uint64) retval;
  delete(@mmap_pgoff[tid]);
}

/* Now we know that the GEMs have all been written to, if they're being submitted. */
kprobe:i915_gem_do_execbuffer /comm == "bude"/
{
  @execbuffer_breadcrumb[tid] = 1;
}
kprobe:i915_vma_instance /(comm == "bude") && @execbuffer_breadcrumb[tid]/
{
  $obj_arg = arg0;
  if(@mmap_addr[$obj_arg]) {
    printf("SUCCESS: I found an object that we've mmap'd!\n");
    printf("  Buffer: %r\n", buf(@mmap_addr[$obj_arg], 64));
  }
}

/*******************
    MMAP METHOD
*******************/

/*
kprobe:i915_gem_mmap_ioctl /comm == "bude"/
{
  $mmap_args = (struct drm_i915_gem_mmap *) arg1;
  printf("Found an mmap for handle %lu, size %lu\n", $mmap_args->handle, $mmap_args->size);
  @mmap_ioctl_handle[tid] = $mmap_args->handle;
  @mmap_ioctl_size[tid] = $mmap_args->size;
}
*/

/* We intercept vm_mmap to get the return address where the GEM will be mapped. */
/*
kretprobe:vm_mmap /(comm == "bude") && (@mmap_ioctl_size[tid])/
{
  printf("Kernel from mmap: %r\n", buf(retval, @mmap_ioctl_size[tid]));
}
*/

/*******************
   PWRITE METHOD
*******************/

/*
kprobe:i915_gem_pwrite_ioctl /comm == "bude"/
{
  $pwrite_args = (struct drm_i915_gem_pwrite *) arg1;
  @pwrite_data_ptr[tid] = $pwrite_args->data_ptr;
  @pwrite_size[tid] = $pwrite_args->size;
}
*/


/* Second, get kernels when they are written with I915_GEM_WRITE */


/* The below section doesn't work for batchbuffers which do not need to be parsed */

/*
kprobe:i915_gem_do_execbuffer /comm == "bude"/
{
  $execbuf = (struct drm_i915_gem_execbuffer2 *) arg2;
  printf("Found an execbuffer with batch_len: %lu\n", $execbuf->batch_len);
}

kprobe:intel_engine_cmd_parser /comm == "bude"/
{
  @batch_length[tid] = (uint32) arg3;
  printf("Kernel size: %lu\n", arg3);
}

kretprobe:i915_gem_object_pin_map /comm == "bude"/
{
  printf("Found a kernel of size %lu\n", @batch_length[tid]);
  printf("%r\n", buf(retval, 32));
}
*/
